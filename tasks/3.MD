ğŸ“Œ 3. szakasz â€“ TÃ¡rgyak Ã©s Inventory kezelÃ©s

ğŸ¯ CÃ©l:
- Megismerni Ã©s hasznÃ¡lni a kollekciÃ³kat (ListÃ¡k)
- Inventory rendszer kialakÃ­tÃ¡sa a karakterekhez
- EgyszerÅ± Ã¶rÃ¶klÅ‘dÃ©s Ã©s polimorfizmus bevezetÃ©se

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

ğŸ§© Fogalmi magyarÃ¡zat:

ğŸ”¸ Mi az a kollekciÃ³?
Egy olyan tÃ­pus, ami tÃ¶bb elemet tud tÃ¡rolni. PÃ©ldÃ¡ul:
  - List<string> nevek = new List<string>();
  - List<Targy> inventory = new List<Targy>();

ğŸ”¸ MiÃ©rt kell Inventory?
A karaktereknek legyenek tÃ¡rgyaik, amiket hasznÃ¡lhatnak, tÃ¡rolhatnak, vagy eldobhatnak. Az inventory ezt a funkciÃ³t valÃ³sÃ­tja meg.

ğŸ”¸ Mi az Ã¶rÃ¶klÅ‘dÃ©s?
Egy osztÃ¡ly (pl. Kard) Ã¶rÃ¶kÃ¶lhet egy mÃ¡sik osztÃ¡lybÃ³l (pl. Targy). Ez azt jelenti, hogy automatikusan megkapja az alap osztÃ¡ly mezÅ‘it Ã©s metÃ³dusait.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

ğŸ“ A. FÃJLOK LÃ‰TREHOZÃSA:

1. Menj a DungeonRPG.Entities projekthez a Rider-ben
2. Hozd lÃ©tre az alÃ¡bbi fÃ¡jlokat:
    - Targy.cs
    - Kard.cs
    - Ital.cs

3. KÃ©sÅ‘bb: mÃ³dosÃ­tsd a Jatekos.cs fÃ¡jlt, hogy tartalmazzon egy `Inventory` listÃ¡t

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

ğŸ› ï¸ B. Targy (Å‘sosztÃ¡ly) lÃ©trehozÃ¡sa

ğŸ“Œ Gondold vÃ©gig:
- Minden tÃ¡rgynak van egy neve
- TalÃ¡n van leÃ­rÃ¡sa, Ã©rtÃ©ke is

ğŸ’¡ TIPP: A `Targy` osztÃ¡ly legyen `abstract`, mert Ã¶nmagÃ¡ban nem szeretnÃ©nk pÃ©ldÃ¡nyosÃ­tani

PÃ©lda (csak vÃ¡zlat):

    public abstract class Targy
    {
        public string Nev { get; protected set; }

        public Targy(string nev)
        {
            Nev = nev;
        }

        public abstract void Hasznal(Karakter celpont);
    }

ğŸ§  KÃ‰RDÃ‰SEK:
- MiÃ©rt Ã©rdemes `abstract`-kÃ©nt Ã­rni?
- Mit jelent az, hogy a `Hasznal()` metÃ³dus is abstract?

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âš”ï¸ C. LeszÃ¡rmazott osztÃ¡ly: Kard

ğŸ“Œ Ez egy tÃ¡madÃ³ tÃ¡rgy, ami megnÃ¶veli a karakter sebzÃ©sÃ©t

Gondold vÃ©gig:
- Mennyi sebzÃ©st adjon hozzÃ¡?
- Hol tÃ¶rtÃ©njen a nÃ¶velÃ©s? A Kardban, vagy a Karakter osztÃ¡lyban?

PÃ©lda:

    public class Kard : Targy
    {
        public int PluszSebzes { get; }

        public Kard(string nev, int pluszSebzes) : base(nev)
        {
            PluszSebzes = pluszSebzes;
        }

        public override void Hasznal(Karakter celpont)
        {
            celpont.NoveliSebzesErteket(PluszSebzes);
        }
    }

ğŸ§  KÃ‰RDÃ‰S:
- Milyen hatÃ¡sa legyen a kardnak? Ideiglenes vagy vÃ©gleges legyen?

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

ğŸ§ª D. LeszÃ¡rmazott osztÃ¡ly: Ital

ğŸ“Œ Ez egy gyÃ³gyÃ­tÃ³ tÃ¡rgy, ami visszaad Ã©leterÅ‘t

Gondold vÃ©gig:
- Mennyi Ã©leterÅ‘t tÃ¶ltsÃ¶n vissza?
- Lehet-e tÃ¶bbfÃ©le ital (pl. gyÃ³gyÃ­tÃ³, bÃ©nÃ­tÃ³)?

PÃ©lda:

    public class Ital : Targy
    {
        public int GyogyitasMennyisege { get; }

        public Ital(string nev, int gyogyitas) : base(nev)
        {
            GyogyitasMennyisege = gyogyitas;
        }

        public override void Hasznal(Karakter celpont)
        {
            celpont.Gyogyit(GyogyitasMennyisege);
        }
    }

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

ğŸ’ E. Inventory lista lÃ©trehozÃ¡sa

Menj a `Jatekos` (vagy Karakter) osztÃ¡lyba, Ã©s adj hozzÃ¡ egy listÃ¡t:

    public List<Targy> Inventory { get; }

    public Jatekos(string nev)
    {
        Inventory = new List<Targy>();
        // tÃ¶bbi alapÃ©rtÃ©k...
    }

ğŸ“Œ Fontos: csak a Karakter tudja mÃ³dosÃ­tani az inventoryt, ne kÃ­vÃ¼lrÅ‘l mÃ³dosÃ­tsd

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â• F. TÃ¡rgy hozzÃ¡adÃ¡sa Ã©s hasznÃ¡lata

â“ Gondold vÃ©gig:
- Hogyan adod hozzÃ¡ a tÃ¡rgyat?
- Ki dÃ¶nti el, mikor hasznÃ¡ljÃ¡k?

Adj metÃ³dusokat a karakterhez:

    public void HozzaadTargy(Targy targy)
    {
        Inventory.Add(targy);
    }

    public void HasznaljaTargyat(int index)
    {
        if (index < 0 || index >= Inventory.Count)
            return;

        Targy kivalasztott = Inventory[index];
        kivalasztott.Hasznal(this);
        Inventory.RemoveAt(index); // egyszer hasznÃ¡lhatÃ³
    }

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

ğŸ§  GONDOLKOZTATÃ“ KÃ‰RDÃ‰SEK:

1. Hogyan tudod megjelenÃ­teni a tÃ¡rgyak nevÃ©t konzolon?
2. Lehet-e egy tÃ¡rgy tÃ¶bbfÃ©lekÃ©ppen mÅ±kÃ¶dÅ‘ (pl. bÃ©nÃ­t Ã©s gyÃ³gyÃ­t)?
3. Ã‰rdemes-e szÃ©tvÃ¡lasztani az egyszer hasznÃ¡lhatÃ³ Ã©s tartÃ³s tÃ¡rgyakat?
4. Hogyan biztosÃ­tod, hogy egy tÃ¡rgy csak akkor legyen hasznÃ¡lhatÃ³, ha tÃ©nyleg van a listÃ¡ban?

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

ğŸ–¥ï¸ H. Konzolos tesztelÃ©s

A ConsoleApp-ban prÃ³bÃ¡ld ki:

1. Hozz lÃ©tre 1 jÃ¡tÃ©kost
2. Adj hozzÃ¡ egy kardot Ã©s egy italt az inventoryjÃ¡hoz
3. Ãrasd ki a tÃ¡rgyak listÃ¡jÃ¡t
4. HasznÃ¡ld fel az elsÅ‘ tÃ¡rgyat
5. NÃ©zd meg, mi tÃ¶rtÃ©nt a jÃ¡tÃ©kos Ã¡llapotÃ¡val

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âœ… Ã–sszefoglalÃ³:

- Megtanultad a kollekciÃ³k (lista) hasznÃ¡latÃ¡t
- Megalkottad az Ã¶rÃ¶klÅ‘dÅ‘ tÃ¡rgy osztÃ¡lyokat
- A karakter most mÃ¡r kÃ©pes tÃ¡rgyakat felvenni, kezelni Ã©s hasznÃ¡lni
