ğŸ“Œ 6. szakasz â€“ TÃ¡rgydobÃ¡s Ã©s vÃ©letlen esemÃ©nyek

ğŸ¯ CÃ©l:
- MegÃ©rteni Ã©s implementÃ¡lni a vÃ©letlenszerÅ± tÃ¡rgydobÃ¡s mechanizmust.
- EsÃ©lyek alapjÃ¡n dÃ¶nteni arrÃ³l, hogy milyen tÃ¡rgyat kap a jÃ¡tÃ©kos a szÃ¶rny legyÅ‘zÃ©se utÃ¡n.
- TÃ¡rgyakat hozzÃ¡adni a karakter inventory-jÃ¡hoz.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

ğŸ§  Fogalmak:

1. VÃ©letlenszerÅ±sÃ©g (Randomness):
   - A jÃ¡tÃ©kban gyakran kell dÃ¶nteni vÃ©letlenszerÅ±en, pl. tÃ¡rgyak esÃ©lyeinek kiszÃ¡mÃ­tÃ¡sa.
   - Ehhez hasznÃ¡ljuk a C# Random osztÃ¡lyÃ¡t.

2. TÃ¡rgy esÃ©lyek (Drop Chances):
   - Minden tÃ¡rgynak megadhatunk egy szÃ¡zalÃ©kos esÃ©lyt, hogy megjelenjen.
   - PÃ©ldÃ¡ul: Kard 30%, GyÃ³gyital 50%, Ritka ital 10%.

3. Inventory kezelÃ©se:
   - A karakter Inventory-ja egy lista, ami tÃ¡rolja a megszerzett tÃ¡rgyakat.
   - Ãšj tÃ¡rgyakat kell hozzÃ¡adni, amikor a jÃ¡tÃ©kos szerzi Å‘ket.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

ğŸ“ A. ElÅ‘kÃ©szÃ¼letek â€“ Random pÃ©ldÃ¡nyosÃ­tÃ¡sa

1. A DungeonService vagy HarcService osztÃ¡lyban hozz lÃ©tre egy Random objektumot, pl.:

    private Random _random = new Random();

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

ğŸ›  B. TÃ¡rgyak Ã©s esÃ©lyek megadÃ¡sa

1. Gondold vÃ©gig, milyen tÃ¡rgyak eshetnek ki a szÃ¶rnyekbÅ‘l.
2. Minden tÃ¡rgyhoz rendelj egy esÃ©ly Ã©rtÃ©ket (int vagy double), pl. 30 (30%).
3. KÃ©szÃ­ts egy metÃ³dust, ami vÃ©letlenszÃ¡mot generÃ¡l (0-99), Ã©s az esÃ©ly alapjÃ¡n eldÃ¶nti, hogy leesik-e a tÃ¡rgy.

PÃ©lda:

    int dobottSzam = _random.Next(100); // 0 Ã©s 99 kÃ¶zÃ¶tt
    if (dobottSzam < targyEsely) 
    {
        // tÃ¡rgy leesik
    }

ğŸ§  KÃ‰RDÃ‰SEK:
- Hogyan tudod a kÃ¼lÃ¶nbÃ¶zÅ‘ esÃ©lyeket egy helyen kezelni?
- Mi tÃ¶rtÃ©nik, ha tÃ¶bb tÃ¡rgy is leeshet egyetlen legyÅ‘zÃ©skor?
- Hogyan kezelnÃ©d, hogy egy szÃ¶rny ritka tÃ¡rgyat is dobhasson?

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

ğŸ§® C. TÃ¡rgy hozzÃ¡adÃ¡sa az inventoryhoz

1. A Karakter osztÃ¡lyban legyen egy lista a tÃ¡rgyaknak:

    public List<Targy> Inventory { get; private set; }

2. KÃ©szÃ­ts egy metÃ³dust a karakterben:

    public void HozzaadTargy(Targy targy)
    {
        Inventory.Add(targy);
    }

3. Amikor a szÃ¶rny legyÅ‘zÃ©se utÃ¡n eldÃ¶ntÃ¶d, hogy leesik-e tÃ¡rgy, hÃ­vd meg ezt a metÃ³dust.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

ğŸ§‘â€ğŸ’» D. Konzolos teszt

1. GenerÃ¡lj egy szÃ¶rnyet
2. SzimulÃ¡ld a harcot
3. A szÃ¶rny legyÅ‘zÃ©se utÃ¡n fusson le a tÃ¡rgy dobÃ¡s logika
4. Ãrd ki, milyen tÃ¡rgy esett ki (ha esett)
5. NÃ©zd meg a karakter Inventory-jÃ¡t a konzolon

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

ğŸ§  Ã–SSZEGZÅ KÃ‰RDÃ‰SEK:

- Hogyan tehetnÃ©d testreszabhatÃ³vÃ¡ a tÃ¡rgydobÃ¡si esÃ©lyeket (pl. nehÃ©zsÃ©gi szint szerint)?
- Milyen adatszerkezet lehet a legjobb az esÃ©lyek Ã©s tÃ¡rgyak Ã¶sszekapcsolÃ¡sÃ¡ra?
- Hogyan kezelnÃ©d az inventory maximÃ¡lis kapacitÃ¡sÃ¡t?

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âœ… Ez a szakasz megtanÃ­t neked:

- VÃ©letlenszÃ¡m generÃ¡lÃ¡s hasznÃ¡latÃ¡t C#-ban
- EsÃ©ly alapÃº dÃ¶ntÃ©sek implementÃ¡lÃ¡sÃ¡t
- GyÅ±jtemÃ©ny (lista) mÃ³dosÃ­tÃ¡sÃ¡t Ã©s hasznÃ¡latÃ¡t
